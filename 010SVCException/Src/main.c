/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void SVC_Handler_c(uint32_t *pBaseStackFrame);

/*
 * Write a program to execute an SVC instruction from thread mode,
 * implement the SVC handler to print the SVC number used.
 * Also increment the SVC number by 4 and return it to the thread mode code and print it.
 * Hints:
 * 1) Write a main() function where you should execute the SVC instruction with an argument (SVC #0x5)
 * 2) Implement the SVC handler
 * 3) In the SVC handler extract the SVC number and print it using printf
 * 4) Increment the SVC number by 4 and return it to the thread mode
 * 5) Include math operations with different SVC Codes
 * 		36 Addition
 * 		37 Subtraction
 * 		38 Multiplication
 * 		39 Division
 */

uint32_t add(uint32_t x, uint32_t y)
{
	uint32_t res;
	/* call svc handler with code 36 */
	__asm volatile("SVC #36");

	/* get the result from R0 */
	__asm volatile ("MOV %0,R0": "=r"(res) ::);
	return res;
}


uint32_t sub(uint32_t x, uint32_t y)
{
	uint32_t res;
	/* call svc handler with code 37 */
	__asm volatile("SVC #37");

	/* get the result from R0 */
	__asm volatile ("MOV %0,R0": "=r"(res) ::);
	return res;
}


uint32_t mul(uint32_t x, uint32_t y)
{
	uint32_t res;
	/* call svc handler with code 38 */
	__asm volatile("SVC #38");

	/* get the result from R0 */
	__asm volatile ("MOV %0,R0": "=r"(res) ::);
	return res;
}


uint32_t div(uint32_t x, uint32_t y)
{
	uint32_t res;
	/* call svc handler with code 39 */
	__asm volatile("SVC #39");

	/* get the result from R0 */
	__asm volatile ("MOV %0,R0": "=r"(res) ::);
	return res;
}


int main(void)
{
	/* SVC instruction  SVC {cond} #imm (range 0-255/8bit) */
//	__asm ("SVC #5"); /* first exercise, not needed later */

	/* not recommended
	register uint32_t data __asm("r0");
	*/

	/* get data from register R0 */
//	uint32_t data; 									/* first exercise, not needed later */
//	__asm volatile ("MOV %0,R0": "=r"(data) ::); 	/* first exercise, not needed later */

//	printf("Data: %ld \n", data);					/* first exercise, not needed later */

	/* addition */
	uint32_t math_result;

	math_result = add(40, -90);
	printf("Addition result: %ld \n", math_result);
	math_result = sub(25, 150);
	printf("Subtraction result: %ld \n", math_result);
	math_result = mul(374, 890);
	printf("Multiplication result: %ld \n", math_result);
	math_result = div(67, -3);
	printf("Division result: %ld \n", math_result);

    /* Loop forever */
	for(;;);
}


__attribute__ ((naked)) void SVC_Handler(void)
{
//	printf("In naked SVC Handler \n"); /* DO NOT PRINT IN NAKED FUNCTIONS ! */
	/* get the value of MSP */
	__asm("MRS r0, MSP");
	/* branch to the C-function SVC Handler */
	__asm("B SVC_Handler_c");
}


void SVC_Handler_c(uint32_t *pBaseOfStackFrame)
{
	uint32_t arg0, arg1, res;

	printf("In SVC Handler \n");

	/* get the return address */
	uint8_t *pReturn_addr = (uint8_t*)pBaseOfStackFrame[6];

	/* decrement the return address by 2 to point to
	 * the opcode of the SVC instruction in the program memory
	 * right before the return, we triggered the svc, so we can
	 * extract the svc number that way
	 */
	pReturn_addr-=2;

	/* extract the SVC number (LSByte of the opcode) from the instruction */
	int svc_number = *pReturn_addr;

	printf("SVC Number is: %d \n", svc_number);

	/* get the args from R0 and R1 */
	arg0 = pBaseOfStackFrame[0];
	arg1 = pBaseOfStackFrame[1];

	switch(svc_number)
	{
	/* addition */
	case 36:
		res = arg0 + arg1;
		break;
	/* subtraction */
	case 37:
		res = arg0 - arg1;
		break;
	/* multiplication */
	case 38:
		res = arg0 * arg1;
		break;
	/* division */
	case 39:
		res = arg0 / arg1;
		break;
	/* default case */
	default:
		printf("invalid SVC Code %d \n", svc_number);
	}

//	svc_number += 4; /* first exercise, not needed later */

	/* set R0 to the result value */
	pBaseOfStackFrame[0] = res;

}
